# Question Backend

# Оглавление
- [1. Введение](#введение)
- [2. Configuration](#configuration)
  - [EncryptionConfig](#encryptionconfig)
  - [MailConfig](#mailconfig)
  - [MvcConfig](#mvcconfig)
  - [WebSecurityConfig](#webSecurityconfig)
- [3. Controller](#controller)
  - [QuestionController](#questioncontroller)
  - [RegistrationController](#registrationcontroller)
  - [UserController](#usercontroller)
- [4. DTO](#dto)
  - [CaptchaResponseDto](#captcharesponsedto)
  - [QuestionDTO](#questiondto)
- [5. Model](#model)
  - [Question](#question)
  - [User](#user)
  - [Role](#role)
- [6. Service](#service)
  - [MailSenderServiceImpl](#mailsenderserviceimpl)
  - [QuestionServiceImpl](#questionserviceImpl)
  - [UserServiceImpl](#userserviceimpl)
- [7. Utils](#utils)
  - [ControllerUtil](#controllerutil)
  - [QuestionHelper](#questionHelper)
- [8. Repository](#repository)
  - [QuestionRepository](#questionrepository)
  - [UserRepository](#userrepository)







**1. Введение**

"Question" - это социальная сеть вопросов, которая позволяет пользователям задавать вопросы, отвечать на них, редактировать и удалять как вопросы, так и ответы. 
Пользователи могут также лайкать вопросы, выражая свои предпочтения. 
Для использования всех функций сервиса необходима авторизация.


## **Configuration**


Пакет конфигураций `org.semenov.config` предоставляет классы, необходимые для настройки и конфигурации приложения.

  ### EncryptionConfig

Класс `EncryptionConfig` находится в пакете `org.semenov.config` и представляет собой конфигурационный класс, используемый для настройки шифрования паролей в приложении. Он содержит метод для создания экземпляра `BCryptPasswordEncoder`, который является реализацией интерфейса `PasswordEncoder` из Spring Security.

**Описание методов**

- **`getPasswordEncoder()`**: Этот метод является бином Spring и возвращает экземпляр `BCryptPasswordEncoder` с настройками шифрования. 
В данном случае, используется алгоритм BCrypt с фактором хеширования 8.

  ### MailConfig

Класс `MailConfig` находится в пакете `org.semenov.config` и представляет собой конфигурационный класс, используемый для настройки отправки электронной почты в приложении. Он содержит метод для создания экземпляра `JavaMailSender`, который предоставляет возможность отправки почтовых сообщений с использованием JavaMail API.

**Описание полей**

- **`host`**: Хост SMTP-сервера для отправки почты.
- **`username`**: Имя пользователя для аутентификации на SMTP-сервере.
- **`password`**: Пароль пользователя для аутентификации на SMTP-сервере.
- **`port`**: Порт SMTP-сервера.
- **`protocol`**: Протокол отправки почты (SMTP).
- **`debug`**: Флаг, указывающий, нужно ли включить отладочный режим для почтовых сообщений.

**Описание методов**

- **`getMailSender()`**: Этот метод является бином Spring и возвращает экземпляр `JavaMailSenderImpl` с настройками для отправки почты. Устанавливает значения хоста, порта, имени пользователя и пароля. Также устанавливает свойства JavaMail, такие как протокол и отладку.

### MvcConfig

Класс `MvcConfig` находится в пакете `org.semenov.config` и представляет собой конфигурационный класс для настройки веб-слоя приложения. Он реализует интерфейс `WebMvcConfigurer` и содержит методы для настройки обработки запросов, представлений и статических ресурсов.

**Описание полей**

- **`uploadPath`**: Путь для загрузки файлов.

**Описание методов**

- **`getRestTemplate()`**: Этот метод является бином Spring и возвращает экземпляр `RestTemplate`, который используется для выполнения HTTP-запросов.

- **`addViewControllers(ViewControllerRegistry registry)`**: Метод добавляет контроллер представлений для маппинга URL `/login` на представление с именем `"login"`.

- **`addResourceHandlers(ResourceHandlerRegistry registry)`**: Метод добавляет обработчики ресурсов для статических файлов. Ресурсы могут быть расположены как на файловой системе, так и внутри JAR-файла.

### WebSecurityConfig

Класс `WebSecurityConfig` находится в пакете `org.semenov.config` и представляет собой конфигурационный класс для настройки безопасности веб-приложения с использованием Spring Security. Он расширяет класс `WebSecurityConfigurerAdapter` и определяет правила доступа к различным URL и настройки аутентификации.

**Описание полей**

- **`userService`**: Сервис для работы с пользователями. Используется для загрузки информации о пользователях в процессе аутентификации.

- **`passwordEncoder`**: Компонент для шифрования паролей пользователей.

**Описание методов**

- **`configure(HttpSecurity http)`**: Метод настраивает правила доступа к URL. Определяет, какие URL доступны анонимным пользователям, а какие требуют аутентификации. Также настраивает страницу входа в систему, возможность запоминания пользователей и выход из системы.

- **`configure(AuthenticationManagerBuilder auth)`**: Метод настраивает аутентификацию. Указывает `AuthenticationManagerBuilder` использовать сервис пользователей для загрузки информации о пользователях и компонент для шифрования паролей.

# Controller

### QuestionController

Класс `QuestionController` находится в пакете `org.semenov.controller` и представляет собой контроллер для обработки запросов, связанных с вопросами в системе. Он обрабатывает запросы на отображение списка вопросов, добавление нового вопроса, изменение вопроса, а также лайки к вопросам.

**Методы контроллера**

- **`greeting(Map<String, Object> model)`**: Метод для отображения главной страницы приложения.

- **`main(String filter, Model model, Pageable pageable, User user)`**: Метод для отображения основной страницы со списком вопросов. Принимает параметры фильтрации, модель для передачи данных в представление, информацию о текущей странице и аутентифицированного пользователя.

- **`add(User user, Question question, BindingResult bindingResult, Model model, MultipartFile file)`**: Метод для добавления нового вопроса. Принимает пользователя, объект вопроса, результаты валидации, модель для передачи данных в представление и файл, прикрепленный к вопросу.

- **`saveFile(Question question, MultipartFile file)`**: Вспомогательный метод для сохранения файла, прикрепленного к вопросу.

- **`userQuestions(User currentUser, User author, Model model, Question question, Pageable pageable)`**: Метод для отображения страницы со списком вопросов конкретного пользователя. Принимает аутентифицированного пользователя, пользователя, чьи вопросы отображаются, модель для передачи данных в представление и информацию о текущей странице.

- **`updateQuestion(User currentUser, Long user, Question question, String text, String tag, MultipartFile file)`**: Метод для обновления информации о вопросе. Принимает информацию о текущем пользователе, идентификатор пользователя, вопрос, текст вопроса, теги и файл, а также сохраняет обновленные данные о вопросе.

- **`like(User currentUser, Question question, RedirectAttributes redirectAttributes, String referer)`**: Метод для добавления и удаления лайка к вопросу. Принимает информацию о текущем пользователе, вопросе, атрибуты для редиректа и URL-адрес, с которого был выполнен запрос.

### RegistrationController

Класс `RegistrationController` находится в пакете `org.semenov.controller` и отвечает за обработку запросов, связанных с регистрацией новых пользователей в системе. Он обрабатывает запросы на отображение страницы регистрации, добавление нового пользователя и активацию учетной записи после регистрации.

**Методы контроллера**

- **`registration()`**: Метод для отображения страницы регистрации пользователей.

- **`addUser(String passwordConfirm, String captchaResponse, User user, BindingResult bindingResult, Model model)`**: Метод для добавления нового пользователя. Принимает подтверждение пароля, ответ на капчу, объект пользователя, результаты валидации, модель для передачи данных в представление. Проверяет введенные данные на корректность, а также наличие пользователя с таким же именем. В случае успешной регистрации перенаправляет на страницу входа.

- **`activate(Model model, String code)`**: Метод для активации учетной записи пользователя. Принимает модель для передачи данных в представление и код активации. Проверяет корректность кода активации и устанавливает статус активации учетной записи.


### UserController

Класс `UserController` находится в пакете `org.semenov.controller` и представляет собой контроллер для обработки запросов, связанных с пользователями в системе. Он обрабатывает запросы на отображение списка пользователей, редактирование профиля пользователя, управление подписками и другие операции, доступные аутентифицированным пользователям.

**Методы контроллера**

- **`userList(Model model)`**: Метод для отображения списка пользователей. Только для пользователей с ролью ADMIN. Принимает модель для передачи данных в представление.

- **`userEditForm(User user, Model model)`**: Метод для отображения формы редактирования информации о пользователе. Только для пользователей с ролью ADMIN. Принимает пользователя, информацию о котором нужно отредактировать, и модель для передачи данных в представление.

- **`userSave(String username, Map<String, String> form, User user)`**: Метод для сохранения изменений информации о пользователе. Только для пользователей с ролью ADMIN. Принимает имя пользователя, карту значений для обновления информации о пользователе и объект пользователя.

- **`getProfile(Model model, User user)`**: Метод для отображения профиля текущего пользователя. Принимает модель для передачи данных в представление и объект текущего пользователя.

- **`updateProfile(User user, String password, String email)`**: Метод для обновления профиля текущего пользователя. Принимает объект текущего пользователя, новый пароль и новый адрес электронной почты.

- **`subscribe(User currentUser, User user)`**: Метод для подписки текущего пользователя на другого пользователя. Принимает текущего пользователя и пользователя, на которого необходимо подписаться.

- **`unsubscribe(User currentUser, User user)`**: Метод для отписки текущего пользователя от другого пользователя. Принимает текущего пользователя и пользователя, от которого необходимо отписаться.

- **`userList(Model model, User user, String type)`**: Метод для отображения списка пользователей (подписчиков или подписок) конкретного пользователя. Принимает модель для передачи данных в представление, пользователя, список которого необходимо отобразить, и тип списка (подписчики или подписки).


# DTO
### CaptchaResponseDto

Класс `CaptchaResponseDto` представляет собой объект передачи данных (DTO), используемый для десериализации ответа на запрос капчи (CAPTCHA) от сервиса Google reCAPTCHA.

**Поля класса:**

- **`success`**: Логическое значение, указывающее на успешность прохождения капчи.

- **`errorCodes`**: Множество строковых значений, содержащих коды ошибок, возникших при прохождении капчи.

**Аннотации:**

- **`@JsonIgnoreProperties(ignoreUnknown = true)`**: Аннотация из библиотеки Jackson, указывающая на игнорирование всех неизвестных свойств при десериализации JSON-объекта.

- **`@JsonAlias("error-codes")`**: Аннотация, позволяющая использовать альтернативное имя `error-codes` в JSON для поля `errorCodes`.

**Методы класса:**

- **`isSuccess()`**: Метод для получения значения успешности прохождения капчи.

- **`setSuccess(boolean success)`**: Метод для установки значения успешности прохождения капчи.

- **`getErrorCodes()`**: Метод для получения множества кодов ошибок капчи.

- **`setErrorCodes(Set<String> errorCodes)`**: Метод для установки множества кодов ошибок капчи.

**Назначение класса:**

Этот класс используется для удобной передачи и обработки ответа от сервиса Google reCAPTCHA при выполнении запроса капчи. После десериализации ответа, объект этого класса содержит информацию о успешности прохождения капчи и коды ошибок, если они есть.

### QuestionDTO

Класс `QuestionDTO` представляет собой объект передачи данных (DTO), который используется для передачи информации о вопросах между различными компонентами приложения. Этот класс содержит основные свойства вопроса и информацию о пользователе-авторе вопроса.

**Поля класса:**

- **`id`**: Уникальный идентификатор вопроса.

- **`text`**: Текст вопроса.

- **`tag`**: Теги, связанные с вопросом.

- **`author`**: Пользователь, который создал вопрос.

- **`filename`**: Имя файла, прикрепленного к вопросу.

- **`likes`**: Количество лайков, полученных у вопроса.

- **`meLiked`**: Флаг, указывающий, поставил ли текущий пользователь лайк данному вопросу.

**Аннотации Lombok:**

- **`@Builder`**: Аннотация, позволяющая использовать паттерн Builder для создания объектов `QuestionDTO` с различными комбинациями значений полей.

- **`@Getter`**: Аннотация, автоматически генерирующая геттеры для всех полей класса.

- **`@Setter`**: Аннотация, автоматически генерирующая сеттеры для всех полей класса.

- **`@AllArgsConstructor`**: Аннотация, генерирующая конструктор, принимающий на вход все поля класса.

- **`@NoArgsConstructor`**: Аннотация, генерирующая конструктор без параметров.

# Model


### Question

Класс `Question` представляет модель вопроса в приложении. Этот класс используется для хранения информации о вопросах, заданных пользователями.

**Поля класса:**

- **`id`**: Уникальный идентификатор вопроса.

- **`fileName`**: Имя файла, прикрепленного к вопросу.

- **`text`**: Текст вопроса.

- **`tag`**: Теги, связанные с вопросом.

- **`author`**: Пользователь, который создал вопрос.

- **`likes`**: Множество пользователей, поставивших лайк данному вопросу.

**Аннотации Lombok:**

- **`@Data`**: Аннотация, которая автоматически генерирует геттеры, сеттеры, методы `equals()`, `hashCode()` и `toString()` для всех полей класса.

- **`@Builder`**: Аннотация, позволяющая использовать паттерн Builder для создания объектов класса `Question` с различными комбинациями значений полей.

- **`@AllArgsConstructor`**: Аннотация, генерирующая конструктор, принимающий на вход все поля класса.

- **`@NoArgsConstructor`**: Аннотация, генерирующая конструктор без параметров.

**Аннотации JPA:**

- **`@Entity`**: Аннотация, указывающая, что данный класс является сущностью JPA.

- **`@Table(name = "questions")`**: Аннотация, указывающая на имя таблицы в базе данных, в которой хранятся объекты класса `Question`.

- **`@Id`**: Аннотация, указывающая на то, что поле `id` является первичным ключом сущности.

- **`@GeneratedValue(strategy = GenerationType.AUTO)`**: Аннотация, определяющая способ генерации значения для первичного ключа.

- **`@ManyToOne(fetch = FetchType.EAGER)`**: Аннотация, указывающая на связь "многие к одному" между вопросом и его автором.

- **`@JoinColumn(name = "user_id")`**: Аннотация, определяющая имя столбца в таблице, который используется для хранения внешнего ключа на пользователя.

- **`@ManyToMany`**: Аннотация, указывающая на связь "многие ко многим" между вопросами и пользователями, которые поставили лайк.

- **`@JoinTable`**: Аннотация, определяющая таблицу для связи "многие ко многим" между вопросами и пользователями, которые поставили лайк.

**Методы класса:**

- **`getAuthorName()`**: Метод для получения имени автора вопроса. Имя автора извлекается с помощью вспомогательного класса `QuestionHelper`.

**Назначение класса:**

Класс `Question` предназначен для хранения информации о вопросах, включая текст вопроса, теги, имя файла прикрепленного к вопросу и информацию об авторе вопроса. Кроме того, класс позволяет хранить информацию о пользователях, которые поставили лайк на вопрос.

### User

Класс `User` представляет модель пользователя в приложении. Этот класс используется для хранения информации о пользователях, их ролях, вопросах, которые они задали, а также о подписках на других пользователей.

**Поля класса:**

- **`id`**: Уникальный идентификатор пользователя.

- **`username`**: Имя пользователя.

- **`password`**: Пароль пользователя.

- **`active`**: Флаг, указывающий на активность пользователя.

- **`email`**: Электронная почта пользователя.

- **`activationCode`**: Код активации, используемый для активации аккаунта пользователя.

- **`roles`**: Роли пользователя.

- **`questions`**: Вопросы, заданные пользователем.

- **`subscribers`**: Подписчики пользователя.

**Аннотации Lombok:**

- **`@Data`**: Аннотация, которая автоматически генерирует геттеры, сеттеры, методы `equals()`, `hashCode()` и `toString()` для всех полей класса.

- **`@Builder`**: Аннотация, позволяющая использовать паттерн Builder для создания объектов класса `User` с различными комбинациями значений полей.

- **`@AllArgsConstructor`**: Аннотация, генерирующая конструктор, принимающий на вход все поля класса.

- **`@NoArgsConstructor`**: Аннотация, генерирующая конструктор без параметров.

**Аннотации JPA:**

- **`@Entity`**: Аннотация, указывающая, что данный класс является сущностью JPA.

- **`@Table(name = "usr")`**: Аннотация, указывающая на имя таблицы в базе данных, в которой хранятся объекты класса `User`.

- **`@Id`**: Аннотация, указывающая на то, что поле `id` является первичным ключом сущности.

- **`@GeneratedValue(strategy = GenerationType.AUTO)`**: Аннотация, определяющая способ генерации значения для первичного ключа.

- **`@ElementCollection`**: Аннотация, используемая для работы с коллекциями простых типов.

- **`@CollectionTable`**: Аннотация, которая определяет таблицу для хранения элементов коллекции.

- **`@Enumerated(EnumType.STRING)`**: Аннотация, указывающая на то, что значения перечисления хранятся как строки в базе данных.

- **`@OneToMany`**: Аннотация, указывающая на связь "один ко многим" между пользователем и вопросами, которые он задал.

- **`@ManyToOne`**: Аннотация, указывающая на связь "многие к одному" между вопросом и его автором.

- **`@JoinTable`**: Аннотация, определяющая таблицу для связи "многие ко многим" между пользователями (подписчиками и каналами).

**Методы класса:**

- Переопределенные методы интерфейса `UserDetails` для использования Spring Security.

**Назначение класса:**

Класс `User` предназначен для хранения информации о пользователях приложения, их аккаунтах, ролях, вопросах и подписках. Этот класс используется как модель данных и сущность JPA для взаимодействия с базой данных.

### Role

Перечисление `Role` представляет различные роли пользователей в системе. В данном контексте, эти роли используются для определения прав доступа пользователей к определенным функциональностям в приложении.

**Значения перечисления:**

- **USER**: Роль пользователя. Предоставляет базовые права доступа, не включающие административные функции.

- **ADMIN**: Роль администратора. Предоставляет полные права доступа к административным функциям приложения.

**Методы класса:**

- **`getAuthority()`**: Переопределенный метод из интерфейса `GrantedAuthority`, возвращающий строковое представление роли. В данном случае, используется имя роли в качестве ее представления.

**Назначение класса:**

Класс `Role` используется для определения ролей пользователей в системе. Роли позволяют управлять правами доступа пользователей к различным частям приложения в зависимости от их роли. Например, администраторам может быть предоставлен доступ к административной панели, в то время как обычным пользователям доступ может быть ограничен.

# Service

### MailSenderServiceImpl

Класс `MailSenderServiceImpl` представляет реализацию интерфейса `MailSenderService` и используется для отправки электронных писем.

**Поля класса:**

- **`javaMailSender`**: Объект `JavaMailSender`, предоставляющий функциональность отправки электронных писем.

- **`username`**: Имя пользователя (адрес электронной почты), используемое для отправки писем.

**Методы класса:**

- **`send(String emailTo, String subject, String message)`**: Метод для отправки электронного письма. Принимает адрес получателя (`emailTo`), тему письма (`subject`) и текст сообщения (`message`). В случае успешной отправки, записывает информацию об отправке в лог. В случае ошибки, записывает информацию об ошибке в лог и выбрасывает исключение.

**Аннотации:**

- **`@Service`**: Аннотация, обозначающая, что этот класс является сервисом, который может быть автоматически обнаружен и настроен в контексте Spring.

- **`@RequiredArgsConstructor`**: Аннотация Lombok, генерирующая конструктор, принимающий все final поля класса в качестве аргументов.

- **`@Slf4j`**: Аннотация Lombok, генерирующая логгер класса.

**Назначение класса:**

Класс `MailSenderServiceImpl` предназначен для отправки электронных писем с использованием JavaMailSender. Он реализует метод `send` интерфейса `MailSenderService`, который позволяет отправлять письма с указанием адреса получателя, темы и текста сообщения.

### QuestionServiceImpl

Класс `QuestionServiceImpl` представляет реализацию интерфейса `QuestionService` и предоставляет методы для работы с вопросами в приложении.

**Поля класса:**

- **`questionRepository`**: Репозиторий вопросов, используемый для взаимодействия с базой данных.

**Методы класса:**

- **`questionList(Pageable pageable, String filter, User user)`**: Метод для получения списка вопросов с учетом пагинации и фильтрации по тегу. Принимает параметры:
    - `pageable`: объект `Pageable`, определяющий параметры пагинации (номер страницы, размер страницы и т. д.).
    - `filter`: строка, содержащая фильтр по тегу.
    - `user`: объект `User`, представляющий текущего пользователя.

- **`questionListForUser(Pageable pageable, User currentUser, User author)`**: Метод для получения списка вопросов для определенного пользователя с учетом пагинации. Принимает параметры:
    - `pageable`: объект `Pageable`, определяющий параметры пагинации (номер страницы, размер страницы и т. д.).
    - `currentUser`: объект `User`, представляющий текущего пользователя.
    - `author`: объект `User`, представляющий автора вопросов, список которого необходимо получить.

**Аннотации:**

- **`@Slf4j`**: Аннотация Lombok, генерирующая логгер класса.

- **`@RequiredArgsConstructor`**: Аннотация Lombok, генерирующая конструктор, принимающий все final поля класса в качестве аргументов.

- **`@Service`**: Аннотация, обозначающая, что этот класс является сервисом, который может быть автоматически обнаружен и настроен в контексте Spring.

**Назначение класса:**

Класс `QuestionServiceImpl` предназначен для работы с вопросами в приложении. Он реализует методы интерфейса `QuestionService`, которые позволяют получать список вопросов с учетом различных параметров, таких как фильтр по тегу или автор вопросов.

### UserServiceImpl

Класс `UserServiceImpl` представляет реализацию интерфейса `UserService` и предоставляет методы для работы с пользователями в приложении.

**Поля класса:**

- **`userRepository`**: Репозиторий пользователей, используемый для взаимодействия с базой данных.
- **`mailSender`**: Сервис отправки электронных писем.
- **`passwordEncoder`**: Кодировщик паролей.
- **`hostname`**: Hostname приложения.

**Методы класса:**

- **`loadUserByUsername(String username)`**: Метод для загрузки пользователя по его имени пользователя (логину). Возвращает объект `UserDetails`, представляющий найденного пользователя.
- **`addUser(User user)`**: Метод для добавления нового пользователя в систему. Создает активационный код, кодирует пароль и отправляет письмо для активации.
- **`sendMessage(User user)`**: Метод для отправки активационного письма пользователю.
- **`activateUser(String code)`**: Метод для активации пользователя по активационному коду.
- **`findAll()`**: Метод для получения списка всех пользователей.
- **`saveUser(User user, String username, Map<String, String> form)`**: Метод для сохранения изменений в профиле пользователя, таких как изменение имени пользователя и назначение ролей.
- **`updateProfile(User user, String password, String email)`**: Метод для обновления профиля пользователя, включая изменение пароля и адреса электронной почты.
- **`subscribe(User currentUser, User user)`**: Метод для подписки текущего пользователя на другого пользователя.
- **`unsubscribe(User currentUser, User user)`**: Метод для отписки текущего пользователя от другого пользователя.

**Аннотации:**

- **`@Slf4j`**: Аннотация Lombok, генерирующая логгер класса.
- **`@RequiredArgsConstructor`**: Аннотация Lombok, генерирующая конструктор, принимающий все final поля класса в качестве аргументов.
- **`@Service`**: Аннотация, обозначающая, что этот класс является сервисом, который может быть автоматически обнаружен и настроен в контексте Spring.

**Назначение класса:**

Класс `UserServiceImpl` предназначен для управления пользователями в приложении. Он реализует методы интерфейса `UserService`, позволяя осуществлять операции добавления, активации, изменения профиля и другие действия с пользователями.

# Utils

### ControllerUtil

Класс `ControllerUtil` предоставляет статический метод для получения ошибок из объекта `BindingResult` и преобразования их в карту, где ключами являются имена полей, а значениями - соответствующие сообщения об ошибке.

**Метод:**

- **`getErrors(BindingResult bindingResult): Map<String, String>`**: Статический метод, который принимает объект `BindingResult` и возвращает карту ошибок, где ключами являются имена полей с суффиксом "Error", а значениями - сообщения об ошибке.

**Назначение класса:**

Класс `ControllerUtil` предназначен для упрощения обработки ошибок в контроллерах. Метод `getErrors` позволяет получить карту ошибок из объекта `BindingResult`, что может быть полезным при валидации данных, введенных пользователем.

### QuestionHelper

Класс `QuestionHelper` предоставляет статический метод для получения имени автора вопроса. Если автор не указан, возвращается строка "<none>".

**Метод:**

- **`getAuthorName(User author): String`**: Статический метод, который принимает объект пользователя `author` и возвращает его имя. Если автор не указан (равен `null`), возвращается строка "<none>".

**Назначение класса:**

Класс `QuestionHelper` предназначен для упрощения работы с данными автора вопроса. Метод `getAuthorName` позволяет получить имя автора и обрабатывать случай, когда автор не указан.


# Repository

### QuestionRepository

Интерфейс `QuestionRepository` является репозиторием для доступа к данным о вопросах. Он расширяет интерфейс `JpaRepository` и предоставляет методы для выполнения запросов к базе данных.

**Методы:**

1. **`findAll(Pageable pageable, User user): Page<QuestionDTO>`**: Выполняет запрос к базе данных для получения всех вопросов с пагинацией. Возвращает страницу объектов `QuestionDTO`, содержащих информацию о вопросах.

2. **`findByTag(String tag, Pageable pageable, User user): Page<QuestionDTO>`**: Выполняет запрос к базе данных для получения вопросов по указанному тегу с пагинацией. Возвращает страницу объектов `QuestionDTO`.

3. **`findByUser(Pageable pageable, User author, User user): Page<QuestionDTO>`**: Выполняет запрос к базе данных для получения вопросов, созданных указанным пользователем, с пагинацией. Возвращает страницу объектов `QuestionDTO`.

**Аннотации:**

- **`@Query`**: Позволяет определить пользовательский JPQL (Java Persistence Query Language) запрос для извлечения данных из базы данных.

### UserRepository

Интерфейс `UserRepository` является репозиторием для доступа к данным о пользователях. Он расширяет интерфейс `JpaRepository` и предоставляет методы для выполнения запросов к базе данных.

**Методы:**

1. **`findByUsername(String username): User`**: Выполняет запрос к базе данных для поиска пользователя по его имени пользователя (`username`). Возвращает объект типа `User` или `null`, если пользователь не найден.

2. **`findByActivationCode(String code): User`**: Выполняет запрос к базе данных для поиска пользователя по его коду активации (`code`). Возвращает объект типа `User` или `null`, если пользователь не найден.

**Назначение интерфейса:**

Интерфейс `UserRepository` позволяет выполнять запросы к базе данных для получения информации о пользователях, такие как поиск пользователя по имени пользователя или по коду активации.